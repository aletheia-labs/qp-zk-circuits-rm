//! Verifier logic for the Wormhole circuit.
//!
//! This module provides the [`WormholeVerifier`] type, which allows for the verification of
//! zero-knowledge proofs generated by the Wormhole circuit.
//!
//! The typical usage flow involves:
//! 1. Initializing the verifier from pre-built circuit data via [`WormholeVerifier::new_from_files(...)`] or [`WormholeVerifier::new_from_bytes()`].
//! 2. Generating a [`ProofWithPublicInputs`].
//! 3. Verifying the proof using [`WormholeVerifier::verify`].
//!
//!# Example
//!
//! Create a verifier and verify a proof:
//!
//!```no_run
//! use wormhole_circuit::inputs::{CircuitInputs, PrivateCircuitInputs, PublicCircuitInputs};
//! use wormhole_circuit::nullifier::Nullifier;
//! use wormhole_circuit::storage_proof::ProcessedStorageProof;
//! use wormhole_circuit::substrate_account::SubstrateAccount;
//! use wormhole_circuit::unspendable_account::UnspendableAccount;
//! use qp_wormhole_prover::WormholeProver;
//! use qp_wormhole_verifier::WormholeVerifier;
//! use plonky2::plonk::circuit_data::CircuitConfig;
//! use std::path::Path;
//!
//! # fn main() -> anyhow::Result<()> {
//! // Create inputs. In practice, each input would be gathered from the real node.
//! let inputs = CircuitInputs {
//!     private: PrivateCircuitInputs {
//!         secret: [1u8; 32],
//!         transfer_count: 0,
//!         funding_account: [2u8; 32].try_into().unwrap(),
//!         storage_proof: ProcessedStorageProof::new(vec![], vec![]).unwrap(),
//!         unspendable_account: [1u8; 32].try_into().unwrap(),
//!     },
//!     public: PublicCircuitInputs {
//!         funding_amount: 1000,
//!         nullifier: [1u8; 32].try_into().unwrap(),
//!         root_hash: [0u8; 32].try_into().unwrap(),
//!         exit_account: [2u8; 32].try_into().unwrap(),
//!     },
//! };
//!
//! // In a real application, a circuit builder binary would serialize the circuit,
//! // and the prover and verifier would load it from a file.
//!
//! // Generate a proof.
//! let config = CircuitConfig::standard_recursion_config();
//! let prover = WormholeProver::new(config);
//! let prover_next = prover.commit(&inputs)?;
//! let proof = prover_next.prove()?;
//!
//! // Verify the proof
//! let verifier =
//!     WormholeVerifier::new_from_files(Path::new("verifier.bin"), Path::new("common.bin"))?;
//! verifier.verify(proof)?;
//! # Ok(())
//! # }
//! ```
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(not(feature = "std"))]
extern crate alloc;

use anyhow::anyhow;
#[cfg(feature = "std")]
use std::path::Path;
use zk_circuits_common::circuit::{C, D, F};

#[cfg(feature = "std")]
use plonky2::plonk::circuit_data::CircuitConfig;
#[cfg(feature = "std")]
use wormhole_circuit::circuit::circuit_logic::WormholeCircuit;

use plonky2::plonk::circuit_data::{
    CommonCircuitData, VerifierCircuitData, VerifierOnlyCircuitData,
};
pub use plonky2::plonk::proof::ProofWithPublicInputs;
use plonky2::util::serialization::DefaultGateSerializer;

pub struct WormholeVerifier {
    pub circuit_data: VerifierCircuitData<F, C, D>,
}

impl WormholeVerifier {
    #[cfg(feature = "std")]
    pub fn new(config: CircuitConfig, circuit_data: Option<VerifierCircuitData<F, C, D>>) -> Self {
        let wormhole_circuit = WormholeCircuit::new(config);
        let circuit_data = match circuit_data {
            Some(circuit_data) => circuit_data,
            None => wormhole_circuit.build_verifier(),
        };

        Self { circuit_data }
    }

    /// Creates a new [`WormholeVerifier`] from verifier and common data bytes.
    pub fn new_from_bytes(
        verifier_bytes: &[u8],
        common_bytes: &[u8],
    ) -> Result<Self, &'static str> {
        let verifier_only = VerifierOnlyCircuitData::from_bytes(verifier_bytes.to_vec())
            .map_err(|_| "Failed to deserialize verifier data from bytes")?;

        let common = CommonCircuitData::from_bytes(common_bytes.to_vec(), &DefaultGateSerializer)
            .map_err(|_| "Failed to deserialize common circuit data from bytes")?;

        let circuit_data = VerifierCircuitData {
            verifier_only,
            common,
        };

        Ok(Self { circuit_data })
    }

    /// Creates a new [`WormholeVerifier`] from a verifier and common data files.
    #[cfg(feature = "std")]
    pub fn new_from_files(
        verifier_data_path: &Path,
        common_data_path: &Path,
    ) -> anyhow::Result<Self> {
        let verifier_bytes = std::fs::read(verifier_data_path)?;

        let verifier_only = VerifierOnlyCircuitData::from_bytes(verifier_bytes).map_err(|e| {
            anyhow!(
                "Failed to deserialize verifier data from {:?}: {}",
                verifier_data_path,
                e
            )
        })?;

        let common_bytes = std::fs::read(common_data_path)?;
        let common =
            CommonCircuitData::from_bytes(common_bytes, &DefaultGateSerializer).map_err(|e| {
                anyhow!(
                    "Failed to deserialize common circuit data from {:?}: {}",
                    common_data_path,
                    e
                )
            })?;

        let circuit_data = VerifierCircuitData {
            verifier_only,
            common,
        };

        Ok(Self { circuit_data })
    }

    /// Verify a [`ProofWithPublicInputs`].
    ///
    /// # Errors
    ///
    /// Returns an error if the proof is not valid.
    pub fn verify(&self, proof: ProofWithPublicInputs<F, C, D>) -> anyhow::Result<()> {
        self.circuit_data
            .verify(proof)
            .map_err(|e| anyhow!("proof verification failed: {}", e))
    }
}
